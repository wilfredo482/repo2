import { DocumentNode, FragmentDefinitionNode, GraphQLSchema, OperationDefinitionNode, OperationTypeNode } from "graphql";
import { ExportedFile, FrameworkGenerator } from "./codegen/codegenHelpers";
export declare type State = {
    set: (key: string, value?: any) => any;
    get: (key: string) => any;
};
export declare type NetlifySite = {
    id: string;
};
export declare const NETLIFY_DIRECTIVE_NAME = "netlify";
export declare const NETLIFY_CACHE_CONTROL_DIRECTIVE_NAME = "netlifyCacheControl";
export declare type NetlifyGraphConfig = {
    functionsPath: string[];
    webhookBasePath: string;
    netlifyGraphImplementationFilename: string[];
    netlifyGraphTypeDefinitionsFilename: string[];
    graphQLOperationsSourceDirectory: string[];
    graphQLSchemaFilename: string[];
    netlifyGraphRequirePath: string[];
    netlifyGraphPath: string[];
    graphQLOperationsSourceFilename?: string[];
    graphQLConfigJsonFilename: string[];
    framework: string;
    extension: string;
    moduleType: "commonjs" | "esm";
    language: "javascript" | "typescript";
    runtimeTargetEnv: "node" | "browser";
};
export declare type ExecutionStrategy = "DYNAMIC" | "PERSISTED";
export declare type CacheStrategy = {
    enabled: boolean;
    timeToLiveSeconds: number;
};
export declare type ExtractedFunction = {
    id: string;
    operationName: string;
    description: string;
    kind: OperationTypeNode;
    executionStrategy: ExecutionStrategy;
    cacheStrategy: CacheStrategy | undefined;
    fallbackOnError: boolean;
    parsedOperation: OperationDefinitionNode;
    operationString: string;
    operationStringWithoutNetlifyDirective: string;
    persistableOperationString: string;
};
export declare type ExtractedFragment = {
    id: string;
    fragmentName: string;
    typeCondition: string;
    description: string;
    kind: "fragment";
    parsedOperation: FragmentDefinitionNode;
    operationString: string;
    operationStringWithoutNetlifyDirective: string;
};
export declare type ParsedFunction = ExtractedFunction & {
    fnName: string;
    safeBody: string;
    returnSignature: string;
    variableSignature: string;
    variableNames: string[];
};
export declare type ParsedFragment = ExtractedFragment & {
    safeBody: string;
    returnSignature: string;
};
export declare type PersistedFunction = ParsedFunction & {
    persistedDocId: string;
};
export declare const defaultSourceOperationsDirectoryName: string[];
export declare const defaultSourceOperationsFilename = "netlifyGraphOperationsLibrary.graphql";
export declare const defaultGraphQLSchemaFilename = "netlifyGraphSchema.graphql";
export declare const defaultNetlifyGraphConfig: NetlifyGraphConfig;
export declare const defaultExampleOperationsDoc = "query ExampleQuery @netlify(doc: \"An example query to start with.\") {\n  __typename\n}";
export declare const generateSubscriptionFunctionTypeDefinition: (schema: GraphQLSchema, fn: ParsedFunction, fragments: Record<string, ParsedFragment>) => string;
export declare const generateSubscriptionFunction: (schema: GraphQLSchema, fn: ParsedFunction, fragments: never[], netlifyGraphConfig: NetlifyGraphConfig) => string;
export declare const queryToFunctionDefinition: (fullSchema: GraphQLSchema, parsedDoc: DocumentNode, persistedQuery: ExtractedFunction, enabledFragments: Record<string, ParsedFragment>) => ParsedFunction | undefined;
export declare const fragmentToParsedFragmentDefinition: (fullSchema: GraphQLSchema, persistedQuery: ExtractedFragment) => ParsedFragment | undefined;
export declare const generateJavaScriptClient: (netlifyGraphConfig: NetlifyGraphConfig, schema: GraphQLSchema, operationsDoc: string, enabledFunctions: ParsedFunction[]) => string;
export declare const generateProductionJavaScriptClient: (netlifyGraphConfig: NetlifyGraphConfig, schema: GraphQLSchema, operationsDoc: string, enabledFunctions: PersistedFunction[], schemaId: string) => string;
export declare const generateFragmentTypeScriptDefinition: (netlifyGraphConfig: NetlifyGraphConfig, schema: GraphQLSchema, fragment: ParsedFragment) => string;
export declare const generateTypeScriptDefinitions: (netlifyGraphConfig: NetlifyGraphConfig, schema: GraphQLSchema, enabledFunctions: ParsedFunction[], enabledFragments: Record<string, ParsedFragment>) => string;
export declare const generateFunctionsSource: (netlifyGraphConfig: NetlifyGraphConfig, schema: GraphQLSchema, operationsDoc: string, queries: Record<string, ExtractedFunction>, fragments: Record<string, ExtractedFragment>) => Promise<{
    clientSource: string;
    typeDefinitionsSource: string;
    functionDefinitions: ParsedFunction[];
}>;
export declare const generatePersistedFunctionsSource: (netlifyGraphConfig: NetlifyGraphConfig, netlifyToken: string, siteId: string, schema: GraphQLSchema, operationsDoc: string, queries: Record<string, PersistedFunction>, fragments: Record<string, ExtractedFragment>, schemaId: string) => Promise<{
    clientSource: string;
    typeDefinitionsSource: string;
    functionDefinitions: ParsedFunction[];
    failedPersistedFunctions: {
        attemptedFunction: ParsedFunction;
        data: any;
        errors: any;
    }[];
}>;
export declare const pluckNetlifyDirective: (definitionNode: OperationDefinitionNode | FragmentDefinitionNode) => {
    id: string;
    description: string;
    executionStrategy: ExecutionStrategy;
} | null;
export declare const pluckNetlifyCacheControlDirective: (definitionNode: OperationDefinitionNode) => {
    cacheStrategy: CacheStrategy | undefined;
    fallbackOnError: boolean;
};
/**
 * Extracts basic functions from a parsed GraphQL operations document
 * @param {DocumentNode} parsedDoc The parsed GraphQL document with @netlify directives
 * @returns {functions: Record<string, ExtractedFunction>, fragments: Record<string, ExtractedFragment>}
 */
export declare const extractFunctionsFromOperationDoc: (parsedDoc: DocumentNode) => {
    functions: Record<string, ExtractedFunction>;
    fragments: Record<string, ExtractedFragment>;
};
/**
 * Given a schema, GraphQL operations doc, a target operationId, and a Netlify Graph config, generates a set of handlers (and potentially components) for the correct framework.
 */
export declare const generateHandlerSource: ({ handlerOptions, netlifyGraphConfig, operationId, operationsDoc, schema, }: {
    handlerOptions: Record<string, boolean>;
    netlifyGraphConfig: NetlifyGraphConfig;
    operationId: string;
    operationsDoc: string;
    schema: GraphQLSchema;
}) => {
    exportedFiles: ExportedFile[];
    operation: OperationDefinitionNode;
} | undefined;
/**
 * Given a schema, GraphQL operations doc, a target operationId, and a Netlify Graph config, generates a set of handlers (and potentially components) for the correct framework.
 */
export declare const generateCustomHandlerSource: ({ handlerOptions, netlifyGraphConfig, operationId, operationsDoc, schema, generate, }: {
    handlerOptions: Record<string, boolean>;
    netlifyGraphConfig: NetlifyGraphConfig;
    operationId: string;
    operationsDoc: string;
    schema: GraphQLSchema;
    generate: FrameworkGenerator;
}) => {
    exportedFiles: ExportedFile[];
    operation: OperationDefinitionNode;
} | undefined;
