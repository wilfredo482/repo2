"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateCustomHandlerSource = exports.generateHandlerSource = exports.extractFunctionsFromOperationDoc = exports.pluckNetlifyCacheControlDirective = exports.pluckNetlifyDirective = exports.generatePersistedFunctionsSource = exports.generateFunctionsSource = exports.generateTypeScriptDefinitions = exports.generateFragmentTypeScriptDefinition = exports.generateProductionJavaScriptClient = exports.generateJavaScriptClient = exports.fragmentToParsedFragmentDefinition = exports.queryToFunctionDefinition = exports.generateSubscriptionFunction = exports.generateSubscriptionFunctionTypeDefinition = exports.defaultExampleOperationsDoc = exports.defaultNetlifyGraphConfig = exports.defaultGraphQLSchemaFilename = exports.defaultSourceOperationsFilename = exports.defaultSourceOperationsDirectoryName = exports.NETLIFY_CACHE_CONTROL_DIRECTIVE_NAME = exports.NETLIFY_DIRECTIVE_NAME = void 0;
var uuid_1 = require("uuid");
var graphql_1 = require("graphql");
var internalConsole_1 = require("./internalConsole");
var graphqlHelpers_1 = require("./graphqlHelpers");
var genericExporter_1 = require("./codegen/genericExporter");
var nextjsExporter_1 = require("./codegen/nextjsExporter");
var remixExporter_1 = require("./codegen/remixExporter");
var oneGraphClient_1 = require("./oneGraphClient");
var capitalizeFirstLetter = function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
};
var replaceAll = function (target, search, replace) {
    var simpleString = search.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return target.replace(new RegExp(simpleString, "g"), replace);
};
exports.NETLIFY_DIRECTIVE_NAME = "netlify";
exports.NETLIFY_CACHE_CONTROL_DIRECTIVE_NAME = "netlifyCacheControl";
exports.defaultSourceOperationsDirectoryName = ["operations"];
exports.defaultSourceOperationsFilename = "netlifyGraphOperationsLibrary.graphql";
exports.defaultGraphQLSchemaFilename = "netlifyGraphSchema.graphql";
exports.defaultNetlifyGraphConfig = {
    extension: "js",
    functionsPath: ["netlify", "functions"],
    netlifyGraphPath: ["netlify", "functions", "netlifyGraph"],
    webhookBasePath: "/.netlify/functions",
    graphQLConfigJsonFilename: [".graphqlrc.json"],
    netlifyGraphImplementationFilename: [
        "netlify",
        "functions",
        "netlifyGraph",
        "index.js",
    ],
    netlifyGraphTypeDefinitionsFilename: [
        "netlify",
        "functions",
        "netlifyGraph",
        "index.d.ts",
    ],
    graphQLOperationsSourceDirectory: [
        "netlify",
        "functions",
        "netlifyGraph",
        "operations",
    ],
    graphQLSchemaFilename: [
        "netlify",
        "functions",
        "netlifyGraph",
        exports.defaultGraphQLSchemaFilename,
    ],
    netlifyGraphRequirePath: ["./netlifyGraph"],
    framework: "custom",
    moduleType: "commonjs",
    language: "javascript",
    runtimeTargetEnv: "node",
};
exports.defaultExampleOperationsDoc = "query ExampleQuery @netlify(doc: \"An example query to start with.\") {\n  __typename\n}";
var lruCacheImplementation = "// Basic LRU cache implementation\nconst makeLRUCache = (max) => {\n  return { max: max, cache: new Map() };\n};\n\nconst getFromCache = (lru, key) => {\n  const item = lru.cache.get(key);\n  if (item) {\n    lru.cache.delete(key);\n    lru.cache.set(key, item);\n  }\n  return item;\n};\n\nconst setInCache = (lru, key, value) => {\n  if (lru.cache.has(key)) {\n    lru.cache.delete(key);\n  }\n  if (lru.cache.size == lru.max) {\n    lru.cache.delete(lru.first());\n  }\n  lru.cache.set(key, value);\n};\n\n// Cache the results of the Netlify Graph API for conditional requests\nconst cache = makeLRUCache(100);\n\nconst calculateCacheKey = (payload) => {\n  return JSON.stringify(payload);\n};";
var generatedNetlifyGraphDynamicClient = function (netlifyGraphConfig) {
    return lruCacheImplementation + "\n\n" + out(netlifyGraphConfig, ["node"], "const httpFetch = (siteId, options) => {\n      const reqBody = options.body || null\n      const userHeaders = options.headers || {}\n      const headers = {\n        ...userHeaders,\n        'Content-Type': 'application/json',\n        'Content-Length': reqBody.length,\n      }\n\n      const timeoutMs = 30_000\n\n      const reqOptions = {\n        method: 'POST',\n        headers: headers,\n        timeout: timeoutMs,\n      }\n\n  const url = 'https://graph.netlify.com/graphql?app_id=' + siteId\n\n  const respBody = []\n\n  return new Promise((resolve, reject) => {\n    const req = https.request(url, reqOptions, (res) => {\n      if (res.statusCode && (res.statusCode < 200 || res.statusCode > 299)) {\n        return reject(\n          new Error(\n            \"Netlify Graph return non-OK HTTP status code\" + res.statusCode,\n          ),\n        )\n      }\n\n      res.on('data', (chunk) => respBody.push(chunk))\n\n      res.on('end', () => {\n        const resString = buffer.Buffer.concat(respBody).toString()\n        resolve(resString)\n      })\n    })\n\n    req.on('error', (error) => {\n      console.error('Error making request to Netlify Graph:', error)\n    })\n\n    req.on('timeout', () => {\n      req.destroy()\n      reject(new Error('Request to Netlify Graph timed out'))\n    })\n\n    req.write(reqBody)\n    req.end()\n  })\n}\n") + "\n" + out(netlifyGraphConfig, ["browser"], "const httpFetch = (siteId, options) => {\n  const reqBody = options.body || null;\n  const userHeaders = options.headers || {};\n  const headers = {\n    ...userHeaders,\n    'Content-Type': 'application/json',\n  };\n\n  const timeoutMs = 30_000;\n\n  const reqOptions = {\n    method: 'POST',\n    headers: headers,\n    timeout: timeoutMs,\n    body: reqBody\n  };\n\n  const url = 'https://graph.netlify.com/graphql?app_id=' + siteId;\n\n  return fetch(url, reqOptions);\n}") + "\n\nconst fetchNetlifyGraph = function fetchNetlifyGraph(input) {\n  const query = input.query;\n  const docId = input.doc_id;\n  const operationName = input.operationName;\n  const variables = input.variables;\n\n  const options = input.options || {};\n  const accessToken = options.accessToken;\n  const siteId = options.siteId || process.env.SITE_ID;\n\n  const payload = {\n    query: query,\n    doc_id: docId,\n    variables: variables,\n    operationName: operationName,\n  };\n\n  let cachedOrLiveValue = new Promise((resolve) => {\n  const cacheKey = calculateCacheKey(payload);\n\n  // Check the cache for a previous result\n  const cachedResultPair = getFromCache(cache, cacheKey);\n\n  let conditionalHeaders = {\n    'If-None-Match': ''\n  };\n  let cachedResultValue;\n\n  if (cachedResultPair) {\n    const [etag, previousResult] = cachedResultPair;\n    conditionalHeaders = {\n      'If-None-Match': etag\n    };\n    cachedResultValue = previousResult;\n  }\n\n  const response = httpFetch(siteId, {\n    method: 'POST',\n    headers: {\n      ...conditionalHeaders,\n      Authorization: accessToken ? 'Bearer ' + accessToken : '',\n    },\n    body: JSON.stringify(payload),\n  });\n\n  response.then((result) => {\n    // Check response headers for a 304 Not Modified\n    if (result.status === 304) {\n      // Return the cached result\n      resolve(cachedResultValue);\n    }\n    else if (result.status === 200) {\n      // Update the cache with the new etag and result\n      const etag = result.headers.get('etag');\n      const resultJson = result.json();\n      resultJson.then((json) => {\n        if (etag) {\n          // Make a note of the new etag for the given payload\n          setInCache(cache, cacheKey, [etag, json])\n        };\n        resolve(json);\n      });\n    } else {\n      return result.json().then((json) => {\n        resolve(json);\n      });\n    }\n  });\n  });\n\n  return cachedOrLiveValue\n}\n";
};
var generatedNetlifyGraphPersistedClient = function (netlifyGraphConfig, schemaId) {
    return lruCacheImplementation + "\n\n" + out(netlifyGraphConfig, ["node"], "const httpGet = (input) => {\n  const userHeaders = input.headers || {};\n  const fullHeaders = {\n    ...userHeaders,\n    'Content-Type': 'application/json'\n  };\n  const timeoutMs = 30_000\n  const reqOptions = {\n    method: 'GET',\n    headers: fullHeaders,\n    timeout: timeoutMs,\n  };\n\n  if (!input.docId) {\n    throw new Error('docId is required for GET requests: ' + input.operationName);\n  }\n\n  const schemaId = input.schemaId || " + (schemaId ? "\"" + schemaId + "\"" : "undefined") + ";\n\n  const encodedVariables = encodeURIComponent(input.variables || \"null\");\n  const url = 'https://graph.netlify.com/graphql?app_id=' + input.siteId + '&doc_id=' + input.docId + (input.operationName ? ('&operationName=' + input.operationName) : '') + (schemaId ? ('&schemaId=' + schemaId) : '') + '&variables=' + encodedVariables;\n        \n  const respBody = []\n\n  return new Promise((resolve, reject) => {\n    const req = https.request(url, reqOptions, (res) => {\n      if (res.statusCode && (res.statusCode < 200 || res.statusCode > 299)) {\n        return reject(\n          new Error(\n            \"Netlify Graph return non-OK HTTP status code\" + res.statusCode,\n          ),\n        )\n      }\n\n      res.on('data', (chunk) => respBody.push(chunk))\n\n      res.on('end', () => {\n        const resString = buffer.Buffer.concat(respBody).toString()\n        resolve(resString)\n      })\n    })\n\n    req.on('error', (error) => {\n      console.error('Error making request to Netlify Graph:', error)\n    })\n\n    req.on('timeout', () => {\n      req.destroy()\n      reject(new Error('Request to Netlify Graph timed out'))\n    })\n\n    req.end()\n  })\n}\n\nconst httpPost = (input) => {\n  const reqBody = input.body || null\n  const userHeaders = input.headers || {}\n  const headers = {\n    ...userHeaders,\n    'Content-Type': 'application/json',\n    'Content-Length': reqBody.length,\n  }\n\n  const timeoutMs = 30_000\n\n  const reqOptions = {\n    method: 'POST',\n    headers: headers,\n    timeout: timeoutMs,\n  }\n\n  const schemaId = input.schemaId || " + (schemaId ? "\"" + schemaId + "\"" : "undefined") + ";\n\n\n  const url = 'https://graph.netlify.com/graphql?app_id=' + input.siteId +\n              (schemaId ? ('&schemaId=' + schemaId) : '');\n  const respBody = []\n\n  return new Promise((resolve, reject) => {\n    const req = https.request(url, reqOptions, (res) => {\n      if (res.statusCode && (res.statusCode < 200 || res.statusCode > 299)) {\n        return reject(\n          new Error(\n            \"Netlify Graph return non-OK HTTP status code\" + res.statusCode,\n          ),\n        )\n      }\n\n      res.on('data', (chunk) => respBody.push(chunk))\n\n      res.on('end', () => {\n        const resString = buffer.Buffer.concat(respBody).toString()\n        resolve(resString)\n      })\n    })\n\n    req.on('error', (error) => {\n      console.error('Error making request to Netlify Graph:', error)\n    })\n\n    req.on('timeout', () => {\n      req.destroy()\n      reject(new Error('Request to Netlify Graph timed out'))\n    })\n\n    req.write(reqBody)\n    req.end()\n  })\n}") + "\n\n" + out(netlifyGraphConfig, ["browser"], "const httpGet = (input) => {\n  const userHeaders = input.headers || {};\n  const fullHeaders = {\n    ...userHeaders,\n    'Content-Type': 'application/json',\n  };\n\n  const timeoutMs = 30_000;\n\n  const reqOptions = {\n    method: 'GET',\n    headers: fullHeaders,\n    timeout: timeoutMs,\n  };\n\n  const encodedVariables = encodeURIComponent(\n    JSON.stringify(input.variables || null)\n  );\n\n  const schemaId = input.schemaId || " + (schemaId ? "\"" + schemaId + "\"" : "undefined") + ";\n\n  const url =\n    'https://graph.netlify.com/graphql?app_id=' +\n    input.siteId +\n    '&doc_id=' +\n    input.docId +\n    (input.operationName ? '&operationName=' + input.operationName : '') +\n    (schemaId ? ('&schemaId=' + schemaId) : '') +\n    '&variables=' +\n    encodedVariables;\n\n  return fetch(url, reqOptions).then((response) => response.text());\n};\n\nconst httpPost = (input) => {\n  const userHeaders = input.headers || {};\n  const fullHeaders = {\n    ...userHeaders,\n    'Content-Type': 'application/json',\n  };\n\n  const reqBody = JSON.stringify({\n    doc_id: input.docId,\n    query: input.query,\n    operationName: input.operationName,\n    variables: input.variables,\n  });\n\n  const timeoutMs = 30_000;\n\n  const reqOptions = {\n    method: 'POST',\n    headers: fullHeaders,\n    timeout: timeoutMs,\n    body: reqBody,\n  };\n\n  const schemaId = input.schemaId || " + (schemaId ? "\"" + schemaId + "\"" : "undefined") + ";\n\n  const url = 'https://graph.netlify.com/graphql?app_id=' + input.siteId +\n              (schemaId ? ('&schemaId=' + schemaId) : '');\n\n  return fetch(url, reqOptions);\n};") + "\n\nconst fetchNetlifyGraph = function fetchNetlifyGraph(input) {\n  const docId = input.doc_id;\n  const operationName = input.operationName;\n  const variables = input.variables;\n\n  const options = input.options || {};\n  const accessToken = options.accessToken;\n  const siteId = options.siteId || process.env.SITE_ID;\n\n  const httpMethod = input.fetchStrategy === 'GET' ? httpGet : httpPost;\n\n  let response;\n\n  if (input.fetchStrategy === 'GET') {\n    response = httpMethod({\n      siteId: siteId,\n      docId: docId,\n      query: input.query,\n      headers: {\n        Authorization: accessToken ? 'Bearer ' + accessToken : '',\n      },\n      variables: variables,\n      operationName: operationName,\n    }).then((result) => JSON.parse(result));\n  } else {\n    const payload = {\n      query: input.query,\n      doc_id: docId,\n      variables: variables,\n      operationName: operationName,\n    };\n\n    let cachedOrLiveValue = new Promise((resolve) => {\n      const cacheKey = calculateCacheKey(payload);\n\n      // Check the cache for a previous result\n      const cachedResultPair = getFromCache(cache, cacheKey);\n\n      let conditionalHeaders = {\n        'If-None-Match': ''\n      };\n      let cachedResultValue;\n\n      if (cachedResultPair) {\n        const [etag, previousResult] = cachedResultPair;\n        conditionalHeaders = {\n          'If-None-Match': etag\n        };\n        cachedResultValue = previousResult;\n      }\n\n      const persistedResponse = httpMethod({\n        siteId: siteId,\n        docId: docId,\n        query: input.query,\n        headers: {\n          ...conditionalHeaders,\n          Authorization: accessToken ? 'Bearer ' + accessToken : '',\n        },\n        variables: variables,\n        operationName: operationName,\n      });\n\n      persistedResponse.then((result) => {\n        // Check response headers for a 304 Not Modified\n        if (result.status === 304) {\n          // Return the cached result\n          resolve(cachedResultValue);\n        }\n        else if (result.status === 200) {\n          // Update the cache with the new etag and result\n          const etag = result.headers.get('etag');\n          const resultJson = result.json();\n          resultJson.then((json) => {\n            if (etag) {\n              // Make a note of the new etag for the given payload\n              setInCache(cache, cacheKey, [etag, json])\n            };\n            resolve(json);\n          });\n        } else {\n          return result.json().then((json) => {\n            resolve(json);\n          });\n        }\n      });\n    });\n\n    response = cachedOrLiveValue;\n  }\n\n  return response;\n};\n";
};
var subscriptionParserReturnName = function (fn) {
    return fn.operationName + "Event";
};
var subscriptionParserName = function (fn) {
    return "parseAndVerify" + fn.operationName + "Event";
};
var subscriptionFunctionName = function (fn) {
    return "subscribeTo" + fn.operationName;
};
var out = function (netlifyGraphConfig, envs, value) {
    if (!envs.includes(netlifyGraphConfig.runtimeTargetEnv)) {
        return "";
    }
    return value;
};
var exp = function (netlifyGraphConfig, envs, name, value) {
    if (!envs.includes(netlifyGraphConfig.runtimeTargetEnv)) {
        return "";
    }
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "exports." + name + " = " + value;
    }
    return "export const " + name + " = " + value;
};
var imp = function (netlifyGraphConfig, envs, name, packageName) {
    if (!envs.includes(netlifyGraphConfig.runtimeTargetEnv)) {
        return "";
    }
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "const " + name + " = require(\"" + packageName + "\")";
    }
    return "import " + name + " from \"" + packageName + "\"";
};
var generateSubscriptionFunctionTypeDefinition = function (schema, fn, fragments) {
    var fragmentDefinitions = Object.entries(fragments).reduce(function (acc, _a) {
        var _b;
        var fragmentName = _a[0], fragment = _a[1];
        return __assign(__assign({}, acc), (_b = {}, _b[fragmentName] = fragment.parsedOperation, _b));
    }, {});
    var parsingFunctionReturnSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperation)(schema, fn.parsedOperation, fragmentDefinitions);
    var variableNames = (fn.parsedOperation.variableDefinitions || []).map(function (varDef) { return varDef.variable.name.value; });
    var variableSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperationVariables)(variableNames, schema, fn.parsedOperation);
    var jsDoc = replaceAll(fn.description || "", "*/", "!")
        .split("\n")
        .join("\n* ");
    return "/**\n* " + jsDoc + "\n*/\nexport function " + subscriptionFunctionName(fn) + "(\n  /**\n   * This will be available in your webhook handler as a query parameter.\n   * Use this to keep track of which subscription you're receiving\n   * events for.\n   */\n  variables: " + (variableSignature === "{}" ? "Record<string, never>" : variableSignature) + ",\n  options?: {\n    /**\n     * The accessToken to use for the lifetime of the subscription.\n     */\n    accessToken?: string | null | undefined;\n    /**\n     * A string id that will be passed to your webhook handler as a query parameter\n     * along with each event.\n     * This can be used to keep track of which subscription you're receiving\n     */\n    netlifyGraphWebhookId?: string | null | undefined;\n    /**\n     * The absolute URL of your webhook handler to handle events from this subscription.\n     */\n    webhookUrl?: string | null | undefined;\n    /**\n     * The secret to use when signing the webhook request. Use this to verify\n     * that the webhook payload is coming from Netlify Graph. Defaults to the\n     * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.\n     */\n    webhookSecret?: string | null | undefined;\n  }) : void\n\nexport type " + subscriptionParserReturnName(fn) + " = " + parsingFunctionReturnSignature + "\n\n/**\n * Verify the " + fn.operationName + " event body is signed securely, and then parse the result.\n */\nexport function " + subscriptionParserName(fn) + " (/** A Netlify Handler Event */ event : WebhookEvent) : null | " + subscriptionParserReturnName(fn) + "\n";
};
exports.generateSubscriptionFunctionTypeDefinition = generateSubscriptionFunctionTypeDefinition;
// TODO: Handle fragments
var generateSubscriptionFunction = function (schema, fn, fragments, netlifyGraphConfig) {
    var _a;
    var patchedWithWebhookUrl = (0, graphqlHelpers_1.patchSubscriptionWebhookField)({
        schema: schema,
        definition: fn.parsedOperation,
    });
    var patched = (0, graphqlHelpers_1.patchSubscriptionWebhookSecretField)({
        schema: schema,
        definition: patchedWithWebhookUrl,
    });
    // TODO: Don't allow unnamed operations as subscription
    var filename = (patched.name && patched.name.value) || "Unknown";
    var body = (0, graphql_1.print)(patched);
    var safeBody = replaceAll(body, "${", "\\${");
    return "const " + subscriptionFunctionName(fn) + " = (\n  variables,\n  rawOptions\n  ) => {\n    const options = rawOptions || {};\n    const netlifyGraphWebhookId = options.netlifyGraphWebhookId;\n    const netlifyGraphWebhookUrl = options.webhookUrl || `${process.env.DEPLOY_URL}" + netlifyGraphConfig.webhookBasePath + "/" + filename + "?netlifyGraphWebhookId=${netlifyGraphWebhookId}`;\n    const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET\n    const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}\n\n    const subscriptionOperationDoc = `" + safeBody + "`;\n\n    fetchNetlifyGraph({\n      query: subscriptionOperationDoc,\n      operationName: \"" + fn.operationName + "\",\n      variables: fullVariables,\n      options: options,\n      fetchStrategy: \"" + (fn.executionStrategy === "PERSISTED" &&
        (((_a = fn.cacheStrategy) === null || _a === void 0 ? void 0 : _a.timeToLiveSeconds) || 0) > 0
        ? "GET"
        : "POST") + "\",\n  })\n}\n\nconst " + subscriptionParserName(fn) + " = (event, options) => {\n  if (!verifyRequestSignature({ event: event }, options)) {\n    console.warn(\"Unable to verify signature for " + filename + "\")\n    return null\n  }\n\n  return JSON.parse(event.body || '{}')\n}";
};
exports.generateSubscriptionFunction = generateSubscriptionFunction;
var makeFunctionName = function (kind, operationName) {
    if (kind === "query") {
        return "fetch" + capitalizeFirstLetter(operationName);
    }
    if (kind === "mutation") {
        return "execute" + capitalizeFirstLetter(operationName) + " ";
    }
    return capitalizeFirstLetter(operationName).trim();
};
var queryToFunctionDefinition = function (fullSchema, parsedDoc, persistedQuery, enabledFragments) {
    var basicFn = {
        id: persistedQuery.id,
        operationString: persistedQuery.operationString,
        description: persistedQuery.description || "",
    };
    var body = basicFn.operationString;
    var safeBody = replaceAll(body, "${", "\\${");
    var parsed = (0, graphql_1.parse)(body, { noLocation: true });
    var operations = parsed.definitions.filter(function (def) { return def.kind === graphql_1.Kind.OPERATION_DEFINITION; });
    var fragmentDefinitions = parsed.definitions.filter(function (def) { return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION; });
    var fragments = Object.values(enabledFragments).reduce(function (acc, def) {
        var _a;
        return (__assign(__assign({}, acc), (_a = {}, _a[def.fragmentName] = def.parsedOperation, _a)));
    }, {});
    if (!operations) {
        internalConsole_1.internalConsole.error("Operation definition is required in " + basicFn.id);
        return;
    }
    var operation = operations[0];
    if (operation.kind !== graphql_1.Kind.OPERATION_DEFINITION) {
        internalConsole_1.internalConsole.error("Definition is not an operation in " + basicFn.id);
        return;
    }
    var returnSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperation)(fullSchema, operation, fragments);
    var variableNames = (operation.variableDefinitions || []).map(function (varDef) { return varDef.variable.name.value; });
    var variableSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperationVariables)(variableNames, fullSchema, operation);
    var operationName = operation.name && operation.name.value;
    if (!operationName) {
        internalConsole_1.internalConsole.error("Operation name is required in " + basicFn.operationString + "\n\tfound: " + JSON.stringify(operation.name));
        return;
    }
    var operationWithoutNetlifyDirective = __assign(__assign({}, operation), { directives: (operation.directives || []).filter(function (directive) { return directive.name.value !== exports.NETLIFY_DIRECTIVE_NAME; }) });
    var persistableOperationString = (0, graphqlHelpers_1.extractPersistableOperation)(parsedDoc, operation) || (0, graphql_1.print)(operation);
    var cacheControl = (0, exports.pluckNetlifyCacheControlDirective)(operation);
    var netlifyDirective = (0, exports.pluckNetlifyDirective)(operation);
    var fn = __assign(__assign({}, basicFn), { fnName: makeFunctionName(operation.operation, operationName), safeBody: safeBody, kind: operation.operation, variableSignature: variableSignature, cacheStrategy: cacheControl.cacheStrategy, fallbackOnError: cacheControl.fallbackOnError, persistableOperationString: persistableOperationString, returnSignature: returnSignature, operationName: operationName, parsedOperation: operation, operationStringWithoutNetlifyDirective: (0, graphql_1.print)(operationWithoutNetlifyDirective), variableNames: variableNames, executionStrategy: (netlifyDirective === null || netlifyDirective === void 0 ? void 0 : netlifyDirective.executionStrategy) || "DYNAMIC" });
    return fn;
};
exports.queryToFunctionDefinition = queryToFunctionDefinition;
var fragmentToParsedFragmentDefinition = function (fullSchema, persistedQuery) {
    var basicFn = {
        id: persistedQuery.id,
        operationString: persistedQuery.operationString,
        description: persistedQuery.description || "",
    };
    var body = basicFn.operationString;
    var safeBody = replaceAll(body, "${", "\\${");
    var parsed = (0, graphql_1.parse)(body, { noLocation: true });
    var operations = parsed.definitions.filter(function (def) { return def.kind === graphql_1.Kind.OPERATION_DEFINITION; });
    var fragmentDefinitions = parsed.definitions.filter(function (def) { return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION; });
    var fragments = fragmentDefinitions.reduce(function (acc, def) {
        var _a;
        return (__assign(__assign({}, acc), (_a = {}, _a[def.name.value] = def, _a)));
    }, {});
    if (!operations) {
        internalConsole_1.internalConsole.error("Operation definition is required in " + basicFn.id);
        return;
    }
    var operation = fragmentDefinitions[0];
    if (operation.kind !== graphql_1.Kind.FRAGMENT_DEFINITION) {
        internalConsole_1.internalConsole.error("Definition is not an operation in " + basicFn.id);
        return;
    }
    var returnSignature = (0, graphqlHelpers_1.typeScriptSignatureForFragment)(fullSchema, operation, fragments);
    var variableNames = (operation.variableDefinitions || []).map(function (varDef) { return varDef.variable.name.value; });
    var variableSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperationVariables)(variableNames, fullSchema, 
    // @ts-ignore TODO: FIX THIS!
    operation);
    var operationName = operation.name && operation.name.value;
    if (!operationName) {
        internalConsole_1.internalConsole.error("Operation name is required in " + basicFn.operationString + "\n\tfound: " + JSON.stringify(operation.name));
        return;
    }
    var operationWithoutNetlifyDirective = __assign(__assign({}, operation), { directives: (operation.directives || []).filter(function (directive) { return directive.name.value !== exports.NETLIFY_DIRECTIVE_NAME; }) });
    var typeCondition = operation.typeCondition.name.value;
    var fn = __assign(__assign({}, basicFn), { safeBody: safeBody, kind: "fragment", returnSignature: returnSignature, fragmentName: operationName, typeCondition: typeCondition, parsedOperation: operation, operationStringWithoutNetlifyDirective: (0, graphql_1.print)(operationWithoutNetlifyDirective) });
    return fn;
};
exports.fragmentToParsedFragmentDefinition = fragmentToParsedFragmentDefinition;
var generateJavaScriptClient = function (netlifyGraphConfig, schema, operationsDoc, enabledFunctions) {
    var operationsWithoutTemplateDollar = replaceAll(operationsDoc, "${", "\\${");
    var safeOperationsDoc = replaceAll(operationsWithoutTemplateDollar, "`", "\\`");
    var functionDecls = enabledFunctions
        .sort(function (a, b) {
        return a.id.localeCompare(b.id);
    })
        .map(function (fn) {
        var _a, _b;
        if (fn.kind === "subscription") {
            var fragments = [];
            return (0, exports.generateSubscriptionFunction)(schema, fn, fragments, netlifyGraphConfig);
        }
        var dynamicFunction = exp(netlifyGraphConfig, ["browser", "node"], fn.fnName, "(\n      variables,\n      options\n      ) => {\n      return fetchNetlifyGraph({\n        query: `" + fn.persistableOperationString + "`,\n        operationName: \"" + fn.operationName + "\",\n        variables: variables,\n        options: options,\n        fetchStrategy: \"" + (fn.executionStrategy === "PERSISTED" &&
            (((_a = fn.cacheStrategy) === null || _a === void 0 ? void 0 : _a.timeToLiveSeconds) || 0) > 0
            ? "GET"
            : "POST") + "\",\n      })\n    }") + "\n";
        var staticFunction = "" + exp(netlifyGraphConfig, ["browser", "node"], fn.fnName, "(\n      variables,\n      options\n    ) => {\n      return fetchNetlifyGraph({\n        query: `" + fn.persistableOperationString + "`,\n        operationName: \"" + fn.operationName + "\",\n        variables: variables,\n        options: options,\n        fetchStrategy: \"" + (fn.executionStrategy === "PERSISTED" &&
            (((_b = fn.cacheStrategy) === null || _b === void 0 ? void 0 : _b.timeToLiveSeconds) || 0) > 0
            ? "GET"
            : "POST") + "\",\n      });\n    }\n");
        return fn.id ? staticFunction : dynamicFunction;
    });
    var exportedFunctionsObjectProperties = enabledFunctions
        .sort(function (a, b) {
        return a.id.localeCompare(b.id);
    })
        .map(function (fn) {
        var isSubscription = fn.kind === "subscription";
        if (isSubscription) {
            if (netlifyGraphConfig.runtimeTargetEnv === "node") {
                var subscriptionFnName = subscriptionFunctionName(fn);
                var parserFnName = subscriptionParserName(fn);
                var jsDoc_1 = replaceAll(fn.description || "", "*/", "")
                    .split("\n")
                    .join("\n* ");
                return "/**\n  * " + jsDoc_1 + "\n  */\n  " + subscriptionFnName + ":" + subscriptionFnName + ",\n  /**\n   * Verify the event body is signed securely, and then parse the result.\n   */\n  " + parserFnName + ": " + parserFnName;
            }
            else {
                return;
            }
        }
        var jsDoc = replaceAll(fn.description || "", "*/", "")
            .split("\n")
            .join("\n* ");
        return "/**\n  * " + jsDoc + "\n  */\n  " + fn.fnName + ": " + (netlifyGraphConfig.moduleType === "commonjs" ? "exports." : "") + fn.fnName;
    })
        .filter(Boolean)
        .join(",\n  ");
    var dummyHandler = exp(netlifyGraphConfig, ["node"], "handler", "() => {\n      // return a 401 json response\n      return {\n        statusCode: 401,\n        body: JSON.stringify({\n          message: 'Unauthorized',\n        }),\n      }\n    }");
    var source = "/* eslint-disable */\n// @ts-nocheck\n// GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!\n" + imp(netlifyGraphConfig, ["node"], "buffer", "buffer") + "\n" + imp(netlifyGraphConfig, ["node"], "crypto", "crypto") + "\n" + imp(netlifyGraphConfig, ["node"], "https", "https") + "\n" + imp(netlifyGraphConfig, ["node"], "process", "process") + "\n\n" + exp(netlifyGraphConfig, ["node"], "verifySignature", "(input) => {\n  const secret = input.secret\n  const body = input.body\n  const signature = input.signature\n\n  if (!signature) {\n    console.error('Missing signature')\n    return false\n  }\n\n  const sig = {}\n  for (const pair of signature.split(',')) {\n    const [key, value] = pair.split('=')\n    sig[key] = value\n  }\n\n  if (!sig.t || !sig.hmac_sha256) {\n    console.error('Invalid signature header')\n    return false\n  }\n\n  const hash = crypto\n    .createHmac('sha256', secret)\n    .update(sig.t)\n    .update('.')\n    .update(body)\n    .digest('hex')\n\n  if (\n    !crypto.timingSafeEqual(\n      Buffer.from(hash, 'hex'),\n      Buffer.from(sig.hmac_sha256, 'hex')\n    )\n  ) {\n    console.error('Invalid signature')\n    return false\n  }\n\n  if (parseInt(sig.t, 10) < Date.now() / 1000 - 300 /* 5 minutes */) {\n    console.error('Request is too old')\n    return false\n  }\n\n  return true\n}") + "\n\n" + generatedNetlifyGraphDynamicClient(netlifyGraphConfig) + "\n\n" + exp(netlifyGraphConfig, ["node"], "verifyRequestSignature", "(request, options) => {\n  const event = request.event\n  const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET\n  const signature = event.headers['x-netlify-graph-signature']\n  const body = event.body\n\n  if (!secret) {\n    console.error(\n      'NETLIFY_GRAPH_WEBHOOK_SECRET is not set, cannot verify incoming webhook request'\n    )\n    return false\n  }\n\n  return verifySignature({ secret, signature, body: body || '' })\n}") + "\n\n" + functionDecls.join("\n\n") + "\n\n/**\n * The generated NetlifyGraph library with your operations\n */\nconst functions = {\n  " + exportedFunctionsObjectProperties + "\n}\n\n" + (netlifyGraphConfig.moduleType === "commonjs"
        ? "exports.default = functions"
        : "export default functions") + "\n\n" + dummyHandler;
    return source;
};
exports.generateJavaScriptClient = generateJavaScriptClient;
var generateProductionJavaScriptClient = function (netlifyGraphConfig, schema, operationsDoc, enabledFunctions, schemaId) {
    var functionDecls = enabledFunctions
        .sort(function (a, b) {
        return a.id.localeCompare(b.id);
    })
        .map(function (fn) {
        var _a, _b;
        if (fn.kind === "subscription") {
            var fragments = [];
            return (0, exports.generateSubscriptionFunction)(schema, fn, fragments, netlifyGraphConfig);
        }
        var dynamicFunction = exp(netlifyGraphConfig, ["browser", "node"], fn.fnName, "(\n      variables,\n      options\n      ) => {\n      return fetchNetlifyGraph({\n        query: `" + replaceAll(fn.persistableOperationString, "`", "`") + "`,\n        operationName: \"" + fn.operationName + "\",\n        variables: variables,\n        options: options,\n        fetchStrategy: \"" + (fn.executionStrategy === "PERSISTED" &&
            (((_a = fn.cacheStrategy) === null || _a === void 0 ? void 0 : _a.timeToLiveSeconds) || 0) > 0
            ? "GET"
            : "POST") + "\",\n      })\n    }") + "\n";
        var staticFunction = "" + exp(netlifyGraphConfig, ["browser", "node"], fn.fnName, "(\n      variables,\n      options\n    ) => {\n      return fetchNetlifyGraph({\n        doc_id: \"" + fn.persistedDocId + "\",\n        operationName: \"" + fn.operationName + "\",\n        variables: variables,\n        options: options,\n        fetchStrategy: \"" + (fn.executionStrategy === "PERSISTED" &&
            (((_b = fn.cacheStrategy) === null || _b === void 0 ? void 0 : _b.timeToLiveSeconds) || 0) > 0
            ? "GET"
            : "POST") + "\",\n      });\n    }\n");
        return fn.executionStrategy === "DYNAMIC"
            ? dynamicFunction
            : staticFunction;
    });
    var exportedFunctionsObjectProperties = enabledFunctions
        .sort(function (a, b) {
        return a.id.localeCompare(b.id);
    })
        .map(function (fn) {
        var isSubscription = fn.kind === "subscription";
        if (isSubscription) {
            if (netlifyGraphConfig.runtimeTargetEnv === "node") {
                var subscriptionFnName = subscriptionFunctionName(fn);
                var parserFnName = subscriptionParserName(fn);
                var jsDoc_2 = replaceAll(fn.description || "", "*/", "")
                    .split("\n")
                    .join("\n* ");
                return "/**\n  * " + jsDoc_2 + "\n  */\n  " + subscriptionFnName + ":" + subscriptionFnName + ",\n  /**\n   * Verify the event body is signed securely, and then parse the result.\n   */\n  " + parserFnName + ": " + parserFnName;
            }
            else {
                return;
            }
        }
        var jsDoc = replaceAll(fn.description || "", "*/", "")
            .split("\n")
            .join("\n* ");
        return "/**\n  * " + jsDoc + "\n  */\n  " + fn.fnName + ": " + (netlifyGraphConfig.moduleType === "commonjs" ? "exports." : "") + fn.fnName;
    })
        .filter(Boolean)
        .join(",\n  ");
    var dummyHandler = exp(netlifyGraphConfig, ["node"], "handler", "() => {\n      // return a 401 json response\n      return {\n        statusCode: 401,\n        body: JSON.stringify({\n          message: 'Unauthorized',\n        }),\n      }\n    }");
    var source = "/* eslint-disable */\n// @ts-nocheck\n// GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!\n  " + imp(netlifyGraphConfig, ["node"], "buffer", "buffer") + "\n  " + imp(netlifyGraphConfig, ["node"], "crypto", "crypto") + "\n  " + imp(netlifyGraphConfig, ["node"], "https", "https") + "\n  " + imp(netlifyGraphConfig, ["node"], "process", "process") + "\n\n" + exp(netlifyGraphConfig, ["node"], "verifySignature", "(input) => {\n  const secret = input.secret\n  const body = input.body\n  const signature = input.signature\n\n  if (!signature) {\n    console.error('Missing signature')\n    return false\n  }\n\n  const sig = {}\n  for (const pair of signature.split(',')) {\n    const [key, value] = pair.split('=')\n    sig[key] = value\n  }\n\n  if (!sig.t || !sig.hmac_sha256) {\n    console.error('Invalid signature header')\n    return false\n  }\n\n  const hash = crypto\n    .createHmac('sha256', secret)\n    .update(sig.t)\n    .update('.')\n    .update(body)\n    .digest('hex')\n\n  if (\n    !crypto.timingSafeEqual(\n      Buffer.from(hash, 'hex'),\n      Buffer.from(sig.hmac_sha256, 'hex')\n    )\n  ) {\n    console.error('Invalid signature')\n    return false\n  }\n\n  if (parseInt(sig.t, 10) < Date.now() / 1000 - 300 /* 5 minutes */) {\n    console.error('Request is too old')\n    return false\n  }\n\n  return true\n}") + "\n\n" + generatedNetlifyGraphPersistedClient(netlifyGraphConfig, schemaId) + "\n\n" + exp(netlifyGraphConfig, ["node"], "verifyRequestSignature", "(request, options) => {\n  const event = request.event\n  const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET\n  const signature = event.headers['x-netlify-graph-signature']\n  const body = event.body\n\n  if (!secret) {\n    console.error(\n      'NETLIFY_GRAPH_WEBHOOK_SECRET is not set, cannot verify incoming webhook request'\n    )\n    return false\n  }\n\n  return verifySignature({ secret, signature, body: body || '' })\n}") + "\n\n" + functionDecls.join("\n\n") + "\n\n/**\n * The generated NetlifyGraph library with your operations\n */\nconst functions = {\n  " + exportedFunctionsObjectProperties + "\n}\n\n" + (netlifyGraphConfig.moduleType === "commonjs"
        ? "exports.default = functions"
        : "export default functions") + "\n\n" + dummyHandler;
    return source;
};
exports.generateProductionJavaScriptClient = generateProductionJavaScriptClient;
var generateFragmentTypeScriptDefinition = function (netlifyGraphConfig, schema, fragment) {
    var jsDoc = replaceAll(fragment.description || "", "*/", "")
        .split("\n")
        .join("\n* ");
    var baseName = fragment.fragmentName;
    var returnSignatureName = capitalizeFirstLetter(baseName);
    var inputSignatureName = capitalizeFirstLetter(baseName) + "Input";
    return "/**\n* " + jsDoc + "\n*/\nexport type " + returnSignatureName + " = " + fragment.returnSignature + ";\n";
};
exports.generateFragmentTypeScriptDefinition = generateFragmentTypeScriptDefinition;
var generateTypeScriptDefinitions = function (netlifyGraphConfig, schema, enabledFunctions, enabledFragments) {
    var fragmentDecls = Object.values(enabledFragments)
        .sort(function (a, b) {
        return a.id.localeCompare(b.id);
    })
        .map(function (fragment) {
        return (0, exports.generateFragmentTypeScriptDefinition)(netlifyGraphConfig, schema, fragment);
    });
    var functionDecls = enabledFunctions
        .sort(function (a, b) {
        return a.id.localeCompare(b.id);
    })
        .map(function (fn) {
        var isSubscription = fn.kind === "subscription";
        if (isSubscription) {
            return (0, exports.generateSubscriptionFunctionTypeDefinition)(schema, fn, enabledFragments);
        }
        var jsDoc = replaceAll(fn.description || "", "*/", "")
            .split("\n")
            .join("\n* ");
        var baseName = fn.operationName;
        var returnSignatureName = capitalizeFirstLetter(baseName);
        var inputSignatureName = capitalizeFirstLetter(baseName) + "Input";
        var shouldExportInputSignature = fn.variableSignature !== "{}";
        var emptyVariablesGuideDocString = fn.variableSignature === "{}"
            ? "/**\n  * Pass `{}` as no variables are defined for this function.\n  */\n  "
            : "";
        var inputSignatureExport = shouldExportInputSignature
            ? "export type " + inputSignatureName + " = " + fn.variableSignature + ";\n"
            : "";
        return inputSignatureExport + "\nexport type " + returnSignatureName + " = " + fn.returnSignature + ";\n\n/**\n * " + jsDoc + "\n */\nexport function " + fn.fnName + "(\n  " + emptyVariablesGuideDocString + "variables: " + (shouldExportInputSignature
            ? inputSignatureName
            : "Record<string, never>") + ",\n  options?: NetlifyGraphFunctionOptions\n): Promise<" + returnSignatureName + ">;";
    });
    var exportedFunctionsObjectProperties = enabledFunctions
        .sort(function (a, b) {
        return a.id.localeCompare(b.id);
    })
        .map(function (fn) {
        var isSubscription = fn.kind === "subscription";
        if (isSubscription) {
            if (netlifyGraphConfig.runtimeTargetEnv === "node") {
                var subscriptionFnName = subscriptionFunctionName(fn);
                var parserFnName = subscriptionParserName(fn);
                var jsDoc_3 = replaceAll(fn.description || "", "*/", "")
                    .split("\n")
                    .join("\n* ");
                return "/**\n* " + jsDoc_3 + "\n*/\n" + subscriptionFnName + ":" + subscriptionFnName + ",\n/**\n * Verify the event body is signed securely, and then parse the result.\n */\n" + parserFnName + ": typeof " + parserFnName;
            }
            else {
                return;
            }
        }
        var jsDoc = replaceAll(fn.description || "", "*/", "")
            .split("\n")
            .join("\n* ");
        return "/**\n* " + jsDoc + "\n*/\n" + fn.fnName + ": typeof " + fn.fnName;
    })
        .filter(Boolean)
        .join(",\n  ");
    var source = "/* eslint-disable */\n// @ts-nocheck\n// GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!\n\nexport type NetlifyGraphFunctionOptions = {\n  /**\n   * The accessToken to use for the request\n   */\n  accessToken?: string;\n  /**\n   * The siteId to use for the request\n   * @default process.env.SITE_ID\n   */\n  siteId?: string;\n}\n\nexport type WebhookEvent = {\n  body: string;\n  headers: Record<string, string | null | undefined>;\n};\n\nexport type GraphQLError = {\n  \"path\": Array<string | number>;\n  \"message\": string;\n  \"extensions\": Record<string, unknown>;\n};\n\n" + fragmentDecls.join("\n\n") + "\n\n" + functionDecls.join("\n\n") + "\n\nexport interface Functions {\n  " + (exportedFunctionsObjectProperties === ""
        ? "Record<string, never>"
        : exportedFunctionsObjectProperties) + "\n}\n\nexport const functions: Functions;\n\nexport default functions;\n";
    return source;
};
exports.generateTypeScriptDefinitions = generateTypeScriptDefinitions;
var generateFunctionsSource = function (netlifyGraphConfig, schema, operationsDoc, queries, fragments) { return __awaiter(void 0, void 0, void 0, function () {
    var fragmentDefinitions, parsedDoc, functionDefinitions, clientSource, typeDefinitionsSource;
    return __generator(this, function (_a) {
        fragmentDefinitions = Object.entries(fragments).reduce(function (acc, _a) {
            var _b;
            var fragmentName = _a[0], fragment = _a[1];
            var parsed = (0, exports.fragmentToParsedFragmentDefinition)(schema, fragment);
            if (parsed) {
                return __assign(__assign({}, acc), (_b = {}, _b[fragmentName] = parsed, _b));
            }
            else {
                return acc;
            }
        }, {});
        parsedDoc = (0, graphql_1.parse)(operationsDoc, { noLocation: true });
        functionDefinitions = Object.values(queries)
            .map(function (query) {
            return (0, exports.queryToFunctionDefinition)(schema, parsedDoc, query, fragmentDefinitions);
        })
            .filter(Boolean)
            .sort(function (a, b) {
            return a.id.localeCompare(b.id);
        });
        clientSource = (0, exports.generateJavaScriptClient)(netlifyGraphConfig, schema, operationsDoc, functionDefinitions);
        typeDefinitionsSource = (0, exports.generateTypeScriptDefinitions)(netlifyGraphConfig, schema, functionDefinitions, fragmentDefinitions);
        return [2 /*return*/, {
                clientSource: clientSource,
                typeDefinitionsSource: typeDefinitionsSource,
                functionDefinitions: functionDefinitions,
            }];
    });
}); };
exports.generateFunctionsSource = generateFunctionsSource;
var generatePersistedFunctionsSource = function (netlifyGraphConfig, netlifyToken, siteId, schema, operationsDoc, queries, fragments, schemaId) { return __awaiter(void 0, void 0, void 0, function () {
    var fragmentDefinitions, parsedDoc, functionDefinitions, persistedFunctionDefinitions, failedPersistedFunctions, _i, functionDefinitions_1, fn, result, persistedFn, clientSource, typeDefinitionsSource;
    var _a, _b, _c;
    return __generator(this, function (_d) {
        switch (_d.label) {
            case 0:
                fragmentDefinitions = Object.entries(fragments).reduce(function (acc, _a) {
                    var _b;
                    var fragmentName = _a[0], fragment = _a[1];
                    var parsed = (0, exports.fragmentToParsedFragmentDefinition)(schema, fragment);
                    if (parsed) {
                        return __assign(__assign({}, acc), (_b = {}, _b[fragmentName] = parsed, _b));
                    }
                    else {
                        return acc;
                    }
                }, {});
                parsedDoc = (0, graphql_1.parse)(operationsDoc, { noLocation: true });
                functionDefinitions = Object.values(queries)
                    .map(function (query) {
                    return (0, exports.queryToFunctionDefinition)(schema, parsedDoc, query, fragmentDefinitions);
                })
                    .filter(Boolean);
                persistedFunctionDefinitions = [];
                failedPersistedFunctions = [];
                _i = 0, functionDefinitions_1 = functionDefinitions;
                _d.label = 1;
            case 1:
                if (!(_i < functionDefinitions_1.length)) return [3 /*break*/, 4];
                fn = functionDefinitions_1[_i];
                if (fn.executionStrategy === "DYNAMIC") {
                    internalConsole_1.internalConsole.log("Skipping dynamic operation", fn.operationName);
                    // @ts-ignore
                    persistedFunctionDefinitions.push(__assign({}, fn));
                    return [3 /*break*/, 3];
                }
                internalConsole_1.internalConsole.log("Persisting: ", fn.operationName);
                return [4 /*yield*/, (0, oneGraphClient_1.executeCreatePersistedQueryMutation)({
                        nfToken: netlifyToken,
                        appId: siteId,
                        description: fn.description,
                        query: fn.persistableOperationString,
                        tags: ["dev"],
                        allowedOperationNames: [fn.operationName],
                        freeVariables: fn.variableNames,
                        fallbackOnError: fn.fallbackOnError,
                        cacheStrategy: fn.cacheStrategy,
                    }, {
                        siteId: siteId,
                        accessToken: netlifyToken,
                    })];
            case 2:
                result = _d.sent();
                persistedFn = (_c = (_b = (_a = result.data) === null || _a === void 0 ? void 0 : _a.oneGraph) === null || _b === void 0 ? void 0 : _b.createPersistedQuery) === null || _c === void 0 ? void 0 : _c.persistedQuery;
                if (persistedFn === null || persistedFn === void 0 ? void 0 : persistedFn.id) {
                    persistedFunctionDefinitions.push(__assign(__assign({}, fn), { persistedDocId: persistedFn.id }));
                }
                else if (result.errors) {
                    failedPersistedFunctions.push(__assign(__assign({}, result), { attemptedFunction: fn }));
                    console.warn("Failed to persist function", fn.operationName, result.errors);
                }
                _d.label = 3;
            case 3:
                _i++;
                return [3 /*break*/, 1];
            case 4:
                clientSource = (0, exports.generateProductionJavaScriptClient)(netlifyGraphConfig, schema, operationsDoc, persistedFunctionDefinitions, schemaId);
                typeDefinitionsSource = (0, exports.generateTypeScriptDefinitions)(netlifyGraphConfig, schema, functionDefinitions, fragmentDefinitions);
                return [2 /*return*/, {
                        clientSource: clientSource,
                        typeDefinitionsSource: typeDefinitionsSource,
                        functionDefinitions: functionDefinitions,
                        failedPersistedFunctions: failedPersistedFunctions,
                    }];
        }
    });
}); };
exports.generatePersistedFunctionsSource = generatePersistedFunctionsSource;
var pluckDirectiveArgEnumValue = function (directive, argName) {
    var _a;
    var targetArg = (_a = directive === null || directive === void 0 ? void 0 : directive.arguments) === null || _a === void 0 ? void 0 : _a.find(function (arg) { return arg.name.value === argName; });
    if (!(targetArg && targetArg.value)) {
        return null;
    }
    if (targetArg.value.kind === graphql_1.Kind.ENUM) {
        return targetArg.value.value;
    }
    return null;
};
var pluckDirectiveArgStringValue = function (directive, argName) {
    var _a;
    var targetArg = (_a = directive === null || directive === void 0 ? void 0 : directive.arguments) === null || _a === void 0 ? void 0 : _a.find(function (arg) { return arg.name.value === argName; });
    if (!(targetArg && targetArg.value)) {
        return null;
    }
    if (targetArg.value.kind === graphql_1.Kind.STRING) {
        return targetArg.value.value;
    }
    return null;
};
var pluckDirectiveArgBooleanValue = function (directive, argName) {
    var _a;
    var targetArg = (_a = directive === null || directive === void 0 ? void 0 : directive.arguments) === null || _a === void 0 ? void 0 : _a.find(function (arg) { return arg.name.value === argName; });
    if (!(targetArg && targetArg.value)) {
        return null;
    }
    if (targetArg.value.kind === graphql_1.Kind.BOOLEAN) {
        return targetArg.value.value;
    }
    return null;
};
var pluckDirectiveArgObjectValue = function (directive, argName) {
    var _a;
    var targetArg = (_a = directive === null || directive === void 0 ? void 0 : directive.arguments) === null || _a === void 0 ? void 0 : _a.find(function (arg) { return arg.name.value === argName; });
    if (!(targetArg && targetArg.value)) {
        return null;
    }
    if (targetArg.value.kind === graphql_1.Kind.OBJECT) {
        return targetArg.value;
    }
    return null;
};
var pluckNetlifyDirective = function (definitionNode) {
    var _a;
    var directive = (_a = definitionNode.directives) === null || _a === void 0 ? void 0 : _a.find(function (localDirective) { return localDirective.name.value === exports.NETLIFY_DIRECTIVE_NAME; });
    if (!directive) {
        return null;
    }
    var docString = pluckDirectiveArgStringValue(directive, "doc") || "";
    var id = pluckDirectiveArgStringValue(directive, "id");
    var executionStrategy = pluckDirectiveArgEnumValue(directive, "executionStrategy");
    if (id === null) {
        id = (0, uuid_1.v4)();
    }
    if (executionStrategy === null ||
        !["DYNAMIC", "PERSISTED"].includes(executionStrategy)) {
        executionStrategy = "DYNAMIC";
    }
    return {
        id: id,
        description: docString,
        executionStrategy: executionStrategy,
    };
};
exports.pluckNetlifyDirective = pluckNetlifyDirective;
var pluckNetlifyCacheControlDirective = function (definitionNode) {
    var _a;
    var defaultStrategy = {
        cacheStrategy: undefined,
        fallbackOnError: false,
    };
    var directive = (_a = definitionNode.directives) === null || _a === void 0 ? void 0 : _a.find(function (localDirective) {
        return localDirective.name.value === exports.NETLIFY_CACHE_CONTROL_DIRECTIVE_NAME;
    });
    if (!directive) {
        return defaultStrategy;
    }
    var rawFallbackOnError = pluckDirectiveArgBooleanValue(directive, "fallbackOnError");
    var fallbackOnError = typeof rawFallbackOnError === "boolean" ? rawFallbackOnError : false;
    var rawCacheStrategy = pluckDirectiveArgObjectValue(directive, "cacheStrategy") || undefined;
    var cacheStrategy = undefined;
    if (rawCacheStrategy) {
        var enabledArg = pluckDirectiveArgBooleanValue(directive, "enabled");
        var enabled = enabledArg || false;
        var field = rawCacheStrategy.fields.find(function (field) { return field.name.value === "timeToLiveSeconds"; });
        if ((field === null || field === void 0 ? void 0 : field.value.kind) === graphql_1.Kind.FLOAT || (field === null || field === void 0 ? void 0 : field.value.kind) === graphql_1.Kind.INT) {
            cacheStrategy = {
                enabled: enabled,
                timeToLiveSeconds: parseFloat(field.value.value),
            };
        }
    }
    var finalStrategy = {
        cacheStrategy: cacheStrategy,
        fallbackOnError: fallbackOnError,
    };
    return finalStrategy;
};
exports.pluckNetlifyCacheControlDirective = pluckNetlifyCacheControlDirective;
/**
 * Extracts basic functions from a parsed GraphQL operations document
 * @param {DocumentNode} parsedDoc The parsed GraphQL document with @netlify directives
 * @returns {functions: Record<string, ExtractedFunction>, fragments: Record<string, ExtractedFragment>}
 */
var extractFunctionsFromOperationDoc = function (parsedDoc) {
    var functions = {};
    var fragments = {};
    parsedDoc.definitions.forEach(function (next) {
        var _a;
        if (next.kind !== graphql_1.Kind.OPERATION_DEFINITION &&
            next.kind !== graphql_1.Kind.FRAGMENT_DEFINITION) {
            return null;
        }
        var key = ((_a = next.name) === null || _a === void 0 ? void 0 : _a.value) || "unknown";
        var netlifyDirective = (0, exports.pluckNetlifyDirective)(next);
        if (netlifyDirective === null) {
            return null;
        }
        var nextWithoutNetlifyDirective = __assign(__assign({}, next), { directives: (next.directives || []).filter(function (directive) {
                return ![
                    exports.NETLIFY_DIRECTIVE_NAME,
                    exports.NETLIFY_CACHE_CONTROL_DIRECTIVE_NAME,
                ].includes(directive.name.value);
            }) });
        if (next.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
            var typeCondition = next.typeCondition.name.value;
            var operation = {
                id: netlifyDirective.id,
                fragmentName: key,
                typeCondition: typeCondition,
                description: netlifyDirective.description,
                parsedOperation: next,
                kind: "fragment",
                operationString: (0, graphql_1.print)(next),
                operationStringWithoutNetlifyDirective: (0, graphql_1.print)(nextWithoutNetlifyDirective),
            };
            fragments[netlifyDirective.id] = operation;
        }
        else if (next.kind === graphql_1.Kind.OPERATION_DEFINITION) {
            var isQuery = next.operation === "query";
            var fnName = makeFunctionName(next.operation, key);
            var cacheControl = isQuery
                ? (0, exports.pluckNetlifyCacheControlDirective)(next)
                : { cacheStrategy: undefined, fallbackOnError: false };
            var persistableOperationString = (0, graphqlHelpers_1.extractPersistableOperation)(parsedDoc, next);
            var operation = {
                id: netlifyDirective.id,
                operationName: key,
                description: netlifyDirective.description,
                cacheStrategy: cacheControl.cacheStrategy,
                fallbackOnError: cacheControl.fallbackOnError,
                persistableOperationString: persistableOperationString || (0, graphql_1.print)(next),
                parsedOperation: next,
                kind: next.operation,
                operationString: (0, graphql_1.print)(next),
                operationStringWithoutNetlifyDirective: (0, graphql_1.print)(nextWithoutNetlifyDirective),
                executionStrategy: netlifyDirective.executionStrategy,
            };
            functions[netlifyDirective.id] = operation;
        }
    });
    return { functions: functions, fragments: fragments };
};
exports.extractFunctionsFromOperationDoc = extractFunctionsFromOperationDoc;
var frameworkGeneratorMap = {
    "Next.js": nextjsExporter_1.nextjsFunctionSnippet.generate,
    Remix: remixExporter_1.remixFunctionSnippet.generate,
    default: genericExporter_1.netlifyFunctionSnippet.generate,
};
var defaultGenerator = genericExporter_1.netlifyFunctionSnippet.generate;
/**
 * Given a schema, GraphQL operations doc, a target operationId, and a Netlify Graph config, generates a set of handlers (and potentially components) for the correct framework.
 */
var generateHandlerSource = function (_a) {
    var handlerOptions = _a.handlerOptions, netlifyGraphConfig = _a.netlifyGraphConfig, operationId = _a.operationId, operationsDoc = _a.operationsDoc, schema = _a.schema;
    var parsedDoc = (0, graphql_1.parse)(operationsDoc, { noLocation: true });
    var operations = (0, exports.extractFunctionsFromOperationDoc)(parsedDoc);
    var functions = operations.functions;
    var fn = functions[operationId];
    if (!fn) {
        internalConsole_1.internalConsole.warn("Operation " + operationId + " not found in graphql, found: " + Object.keys(functions).join(", ") + "}");
        return;
    }
    var odl = (0, genericExporter_1.computeOperationDataList)({
        query: fn.operationString,
        variables: [],
    });
    var generate = frameworkGeneratorMap[netlifyGraphConfig.framework] || defaultGenerator;
    var exportedFiles = generate({
        netlifyGraphConfig: netlifyGraphConfig,
        operationDataList: odl.operationDataList,
        schema: schema,
        options: handlerOptions,
    }).exportedFiles;
    return { exportedFiles: exportedFiles, operation: fn.parsedOperation };
};
exports.generateHandlerSource = generateHandlerSource;
/**
 * Given a schema, GraphQL operations doc, a target operationId, and a Netlify Graph config, generates a set of handlers (and potentially components) for the correct framework.
 */
var generateCustomHandlerSource = function (_a) {
    var handlerOptions = _a.handlerOptions, netlifyGraphConfig = _a.netlifyGraphConfig, operationId = _a.operationId, operationsDoc = _a.operationsDoc, schema = _a.schema, generate = _a.generate;
    var parsedDoc = (0, graphql_1.parse)(operationsDoc, { noLocation: true });
    var operations = (0, exports.extractFunctionsFromOperationDoc)(parsedDoc);
    var fn = operations.functions[operationId];
    if (!fn) {
        internalConsole_1.internalConsole.warn("Operation " + operationId + " not found in graphql among:\n [" + Object.keys(operations).join(",\n ") + "]");
        return;
    }
    var odl = (0, genericExporter_1.computeOperationDataList)({
        query: fn.operationString,
        variables: [],
    });
    var exportedFiles = generate({
        netlifyGraphConfig: netlifyGraphConfig,
        operationDataList: odl.operationDataList,
        schema: schema,
        options: handlerOptions,
    }).exportedFiles;
    return { exportedFiles: exportedFiles, operation: fn.parsedOperation };
};
exports.generateCustomHandlerSource = generateCustomHandlerSource;
//# sourceMappingURL=netlifyGraph.js.map